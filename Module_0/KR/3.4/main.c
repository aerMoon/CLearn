/*
 * Упражнение 3.4. При условии, что для представления чисел используется
 * дополнительный код, наша версия itoa не справляется с самым большим 
 * по модулю отрицательным числом, значение которого равняется -(2 n-1), 
 * где n — размер слова. Объясните, чем это вызвано. Модифицируйте 
 * программу таким образом, чтобы она давала правильное значение 
 * указанного числа независимо от машины, на которой выполняется.
 *
 * Ответ: Собсна, максимальное отрицательное значение int = -2147483648
 * тогда как максимальное положительное значение int внезапно 2147483647
 * вот эта разница на единицу и создавала ошибку при отбросе знака.
 *
 */

#include <stdio.h>
#include <math.h>
#include <limits.h>

void reverse(char buf[]) {

    int len = 0;
    while (buf[len] != '\0')
        ++len;
    --len;
    for (int i = 0; len > i; i++, len--) {
        int ch = buf[i];
        buf[i] = buf[len];
        buf[len] = ch;
    }
}

/* itoa: преобразование n в строку s */
void itoa (int n, char s[])
{
    int i, sign;
	if ((sign = n) < 0) /* сохраняем знак */
        n = abs(n - 1); /* делаем n положительным */
	i = 0;
	do { /* генерируем цифры в обратном порядке */
        s[i++] = n % 10 + '0'; /* следующая цифра */
	} while ((n /= 10) > 0); /* исключить ее */
    if (sign < 0) {
        s[0] += 1;
		s[i++] = '-';
    }
	s[i] = '\0';
	reverse(s);
}

#define MAX_BUF 1024

int main(void) {

    char buf[MAX_BUF + 1];
    int max_neg = -1 * pow(2.0, sizeof(int) * CHAR_BIT - 1);
    printf("Максимальное положительное: %d\n", (int)pow(2.0, sizeof(int) * CHAR_BIT - 1));
    printf("Максимальное отрицательное: %d\n", max_neg);
    itoa(max_neg, buf);

    putchar('\n');
    int pos = 0;
    while (buf[pos] != '\0') {
        putchar(buf[pos]);
        ++pos;
    }
    putchar('\n');
    return 0;
}
